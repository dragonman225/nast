import { CSS, COLOR } from "./constants"
import renderCode from "./util-prismjs"
import { getBookmarkLinkFromNotionPageURL } from "./notion-utils"

/**
 * Safe HTML generated by this renderer.
 */
export type HTML = string

/**
 * Render children nodes.
 * @param {NAST.Block[]} nodeArray - Children nodes to render.
 * @param {Function} renderNext - Render controller that will assign a node to 
 * a corresponding render function when iterating through nodeArray.
 * @returns {string} HTML.
 */
function renderChildren(
  nodeArray: NAST.Block[],
  renderNext: Function
): string {
  const childrenHTMLArr = nodeArray.map(node => {
    const html = `\
<div ${node.uri ? `id="${node.uri}"` : ""}>
  ${renderNext(node)}
</div>`
    return html
  })
  return childrenHTMLArr.join("")
}

/**
 * Render a block.
 * @param {NAST.Block} node The block node itself.
 * @param {string} contentHTML The HTML content inside the block.
 * @param {string} tag The HTML tag to use for the block.
 * @returns {string} HTML
 */
function renderBlock(
  node: NAST.Block,
  contentHTML: string,
  tag = "div"
): string {
  const blockColorClass = node.color ? colorElemClass("block", node.color) : ""
  const html = `\
<${tag} class="${CSS.blockClass} ${CSS.blockClass}--${node.type} ${blockColorClass}">\
${contentHTML}\
</${tag}>`
  return html
}



/**
 * Map color string in NAST to another string that is intended to use
 * as a CSS class.
 * @param {string} str A valid color string in NAST.
 * @returns {string} The CSS class string for the color string.
 */
function colorElemClass(
  elemClass: string,
  color: string
): string {
  const colorPrefix = `${elemClass}--color-`
  const bgPrefix = `${elemClass}--bg-`
  switch (color) {
    case COLOR.gray:
      return colorPrefix + "gray"
    case COLOR.brown:
      return colorPrefix + "brown"
    case COLOR.orange:
      return colorPrefix + "orange"
    case COLOR.yellow:
      return colorPrefix + "yellow"
    case COLOR.green:
      return colorPrefix + "green"
    case COLOR.blue:
      return colorPrefix + "blue"
    case COLOR.purple:
      return colorPrefix + "purple"
    case COLOR.pink:
      return colorPrefix + "pink"
    case COLOR.red:
      return colorPrefix + "red"
    case COLOR.grayBg:
      return bgPrefix + "gray"
    case COLOR.brownBg:
      return bgPrefix + "brown"
    case COLOR.orangeBg:
      return bgPrefix + "orange"
    case COLOR.yellowBg:
      return bgPrefix + "yellow"
    case COLOR.greenBg:
      return bgPrefix + "green"
    case COLOR.blueBg:
      return bgPrefix + "blue"
    case COLOR.purpleBg:
      return bgPrefix + "purple"
    case COLOR.pinkBg:
      return bgPrefix + "pink"
    case COLOR.redBg:
      return bgPrefix + "red"
    default:
      return colorPrefix + "default"
  }
}

/**
 * Escape special characters in a string.
 * 
 * @see https://github.com/facebook/react/blob/1034e26fe5e42ba07492a736da7bdf5bf2108bc6/packages/react-dom/src/server/escapeTextForBrowser.js
 * @see https://github.com/rack/rack/issues/27
 * 
 * @param {string} str Unescaped string.
 * @returns {string} Escaped string.
 */
function escapeString(
  str?: string
): string {

  if (!str) return ""

  let character, escapedString = ""

  for (let i = 0; i < str.length; ++i) {
    character = str.charAt(i)
    switch (character) {
      case "<":
        escapedString += "&lt;"
        break
      case ">":
        escapedString += "&gt;"
        break
      case "&":
        escapedString += "&amp;"
        break
      case "'":
        escapedString += "&#x27;"
        break
      case "\"":
        escapedString += "&quot;"
        break
      // case "/":
      //   escapedString += "&#x2F;"
      //   break
      // case "\"":
      //   escapedString += "&quot;"
      //   break
      default:
        escapedString += character
    }
  }

  return escapedString

}

/**
 * Render NAST.SemanticString[].
 * @param ssArr
 * @param isCode - Whether it should be treated as code.
 * @param lang - One of programming languages listed in 
 * `render-utils-prismjs.ts`.
 */
function renderSemanticStringArray(
  ssArr: NAST.SemanticString[],
  isCode?: boolean, codeLang?: string
): HTML {

  if (!ssArr) return ""

  const htmlPartials = ssArr.map(ss => {
    if (isCode) {
      const safeText = renderCode(ss[0], codeLang)
      const formattings = ss[1]
      return renderSemanticString(safeText, formattings)
    } else {
      const safeText = escapeString(ss[0])
      const formattings = ss[1]
      return renderSemanticString(safeText, formattings)
    }
  })

  return htmlPartials.join("")

}

function renderSemanticString(
  safeText: string,
  formattings?: NAST.FormattingAll[]
): HTML {

  if (!formattings) {
    return safeText
  } else {
    let html = safeText
    for (let n = 0; n < formattings.length; n++) {
      html = addFormattingToHTML(html, formattings[n])
    }
    return html
  }

}

function addFormattingToHTML(
  html: HTML,
  formatting: NAST.FormattingBasic | NAST.FormattingMentionDate
    | NAST.FormattingMentionIndividual | NAST.FormattingMentionResource
): HTML {

  if (!formatting) {
    return html
  }

  switch (formatting[0]) {
    /* Bold */
    case "b":
      return `<strong>${html}</strong>`
    /* Italic */
    case "i":
      return `<em>${html}</em>`
    /* Strike */
    case "s":
      return `<del>${html}</del>`
    /* Link */
    case "a":
      return `<a href="${getBookmarkLinkFromNotionPageURL(formatting[1])}">${html}</a>`
    /* Inline Code */
    case "c":
      return `<code>${html}</code>`
    /* Color or Background Color */
    case "h":
      const color = formatting[1]
      return `<span class="${colorElemClass("text", color)}">${html}</span>`
    /* Comment */
    case "m":
      return `<span class="color-comment">${html}</span>`
    /** Inline Mention Individual */
    case "u":
      return renderInlineMentionIndividual(formatting[1])
    /** Inline Mention Resource */
    case "p":
      return renderInlineMentionResource(formatting[1])
    /** Inline Mention Date */
    case "d":
      return renderInlineMentionDate(formatting[1])
    default:
      console.log(`Unsupported formatting: ${formatting[0]}`)
      return html
  }

}

function renderInlineMentionIndividual(data: NAST.Individual): HTML {
  return `<span class="color-mention">@${escapeString(data.name)}</span>`
}

function renderInlineMentionResource(data: NAST.Resource): HTML {
  return `<span class="color-mention">\
<a href="${data.uri}">${renderSemanticStringArray(data.title)}</a></span>`
}

function renderInlineMentionDate(data: NAST.DateTime): HTML {
  const date = new Date(data.start_date)
  return `<span class="color-mention">@\
${date.getUTCFullYear()}/${date.getUTCMonth() + 1}/${date.getUTCDate()}\
</span>`
}

/**
 * If the icon is an url, wrap it with `<img>`.
 * @param {string} icon 
 */
function renderIconToHTML(icon?: string): HTML {
  if (!icon) return ""

  const re = /^http/
  if (re.test(icon)) {
    return `<span><img class="inline-img-icon" src="${icon}"></span>`
  } else {
    return icon ? `<span>${icon}</span>` : ""
  }
}

function htmlTag(strings: TemplateStringsArray, ...vars: string[]) {
  const unformattedStrings =
    strings.map(str => str.replace(/\n/g, "").trim())
  let result = ""
  for (let i = 0; i < vars.length; i++) {
    result += unformattedStrings[i]
    result += vars[i]
  }
  result += unformattedStrings[unformattedStrings.length - 1]
  return result
}

export {
  renderChildren,
  renderBlock,
  renderSemanticStringArray,
  colorElemClass,
  renderIconToHTML,
  escapeString,
  htmlTag
}